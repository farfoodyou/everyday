# 数据结构
[toc]

跳过了16，17节
## 第一章 概论
程序设计：为计算机处理问题编制一组指令集
算法：处理问题的策略
数据结构：问题的数学模型
算法 + 数据结构 = 程序设计
数据结构描述现实世界实体的数学模型（非数值计算）及其上的操作在计算机中的表示和实现。

### 1.2 基本概念
数据：所以能被输入到计算机中，且被计算机处理的符号的集合，计算机操作的对象的总称，是计算机处理的信息的某种特定的符号表示形式。
数据元素：数据中的一个‘个体’，数据结构中讨论的基本单位。
数据项：数据结构中讨论的最小单位，数据元素是数据项的集合
数据结构：带结构的数据元素的集合

数据的逻辑结构可归结为以下四类
线性结构、树形结构、图状结构、集合结构

数据结构的形式定义为：数据结构是一个二元组Data_Structures=(D,S)
其中：D是数据元素的有限集，S是D上关系的有限集

数据的存储结构：逻辑结构在存储器中的映像
数据元素的映像的方法：用二进制位（bit）的位串来表示数据元素
关系的映像方法：表示`<x,y>`的方法
1、顺序映像，以存储地址的相邻表示后继关系
2、链式映像，以附加信息（指针）表示后继关系

二、数据类型
数据类型是一个值的集合和定义在此集合上的一组操作的总称。

三、抽象数据类型
(Abstract Data Type简称ADT)
是指一个数学模型以及定义在此数学模型上的一组操作。

两个重要特征 
数据抽象：用ADT描述程序处理的实体时，强调的是其本质的特征，其所能完成的功能以及它和外部用户的接口（即外界使用它的方法）
基本操作：初始化条件和操作结果

抽象数据类型的表示和实现，抽象数据类型需要通过固有数据类型来实现。
### 1.3 算法和算法的衡量
一、算法
算法是为了解决某类问题而规定的一个有限长的操作序列。
1、有穷性：对任一一组合法输入值，在执行有穷步骤之后一定能结束，每个步骤能在有限时间完成。（PS：合理的有限，不是数学上的有限）
2、确定性：对与每种情况下有确定执行路径
3、可行性：算法中的所有操作都必须足够基本
4、有输入
5、有输出

二、算法设计的原则
1、正确性 c级，对精心选择的、典型、苛刻的切带有刁难行的输入数据够能够得到满足要求的结果。
2、可读性 易于人的理解
3、健壮性 当输入的数据非法时，算法应当恰当地做出反应或进行相应处理
4、高效率与低存储量需求 和问题规模有关

三、算法效率的衡量方法和准则
两种，事后统计法，事前分析估计法

和算法执行时间有关的因素：
1、算法选用的策略
2、问题的规模
3、编写程序的语言
4、编译程序产生的机器代码的质量
5、计算机执行指令的速度

考虑前两条
随着问题规模$n$的增长，算法执行时间的增长率和$f(n)$的增长率相同
$$T(n)=O(f(n))$$
称$T(n)$为算法的(渐进)时间复杂度

算法 = 控制结构 + 原操作
算法执行时间 与 原操作执行数量数量成正比
对于问题来说的 基本操作 可以认为是原操作

算法的存储量包括 输入数据 程序本身 辅助变量

## 第二章 线性结构
线性结构是一个数据元素的有序(次序)集
基本特征：
1、存在唯一一个第一元素
2、存在唯一一个最后元素
3、除了最后元素，都有唯一后继
4、除了第一元素，都有唯一前驱

### 2.1 线性表的类型定义
ADT List{
    数据对象：
        $$D = \{ a_i | a_i \in ElemSet,i=1,2...n, n\geq0\}$$
    数据关系：
        $$R1=\{<a_{i-1},a_i>|a_{i-1},a_i\in D,i=2...n\}$$
}
基本操作
1、结构初始化
2、销毁结构
3、引用型操作 判空 求长度 求前驱 求后继 获取位置 遍历
4、加工型操作 清空 赋值 插入 删除 

操作
初始条件：
操作结果：
### 2.2 线性表顺序实现

### 2.3 线性表链式实现

### 2.4 一元多项式的表示

## 第三章 栈和队列
栈：后进先出
队列：先进先出
### 3.1 栈的类型定义

### 3.2 栈的应用举例
例 1 数制转换
用栈存储，输出
// 虽然数组就可以实现，但是可读性不好，容易掩盖问题本质
例 2 括号匹配检验

例 3 行编辑程序问题
用#表示退格，@表示这一行前面都不要了
例 4 迷宫求解
通常用“穷举求解”，#表示当前位置，
非递归写法，要用到栈，更容易理解问题的本质
例 5 表达式求值
前缀式 中缀式 后缀式
结论
1.操作数相对次序不变
2.运算符相对次序不同
3.中缀式丢失括弧信息，运算次序不确定
4.前缀式，连续出现两个操作数和前面紧靠操作符，构成最小表达式
5.后缀式，在式中出现的顺序就是表达式运算顺序

#### 如何从表达式求得后缀式
从左到右不知道后面信息，
队列Q存操作数直接存入，用栈S存操作符，
每遇到一个操作数X判断优先级，比栈顶低就pop，比栈顶高就push X
左括弧，右括弧，左低，右优先级高

#### 实现递归
保存结算结果，清楚缓存区，返回结构
递归工作栈，递归工作记录，当前活动记录，当前环境指南
汉诺塔
### 3.3 栈类型的实现
顺序栈
栈顶指针，指向栈顶元素上一个
链表栈
栈顶指针，指向栈顶元素
### 3.4 队列的类型定义

基本操作： 
InitQueue(&Q) DestroyQueue(&Q)
QueueEmpty(Q) QueueLength(Q)
GetHead(Q,&e) ClearQueue(&Q)
EnQueue(&Q,e) DeQueue(&Q,&e)

### 3.5 队列类型的实现
链队列，顺序队列
循环队列
对满和空的状态描述

## 第四章 串
### 4.1 串的抽象数据类型的定义
基本操作
StrAssign(&T,chars) StrCompare(S,T)
StrCopy(&T,S) StrLength(S)
DestroyString(&S) Concat(&T,S1,S2)
StrEmpty(S)

SubString(&Sub,S,pos,len) Index(S,T,pos)
Replace(&S,T,V) 
StrInsert(&S,pos,T) StrDelete(&S,pos,len)

最小六个操作子集： 复制，赋值，比较，求长，连接，求子串
### 4.2 串的表示和实现 
一、
二、堆分配存储表示

三、块链存储
每个节点放一个数据元素，链表存储密度太低。
要放一个字符串才靠谱，
### 4.3 串的模式匹配算法
Index(S,T,pos)
一、简单算法
```cpp
i = pos, j = 1;
while(i <= len1 && j <= len2){
    if(S[i] == S[j]){ ++i; ++j;}
    else { i = i-j+2; j = 1;}
}
```
二、首位匹配算法

三、KMP
时间复杂度O(N),解决了指针回溯,
求next函数值的过程是一个递推过程。
next[1] = 0;
假设 next[j] = k;且T[j] = T[k];
则 next[j+1] = k+1
若 T[j] != T[k];
则往前回溯，检查T[j] = T[?]
```cpp
int next[maxn];
void *Next(&T){
    int i = 0, j = 0;
    next[0] = 0;
    while(i < len){
        if(j == 0 || T[i] == T[j]){
            i++; j++; next[i] = j;
        } else {
            j = next[j];
        }
    }
}
int Index_KMP(S,T,pos){
    i = pos, j = 1;
    while(i <= len1 && j <= len2){
        if(j==0 || S[i] == S[j]){
            i++; j++;
        }else j = next[j];
    }
    if(j>len2)return i-len2;
    else return 0;
}
```
还有改进Next函数值

## 第五章 数组和广义表

### 5.1 数组的类型定义
基本操作：
InitArray(&A)
DestroyArray(&A)
Value(A,&e,index)
Assign(&A,e,index)
### 5.2 数组的顺序表示和实现
Loc(i,j) 第 i 行 第 j 列
### 5.3 稀疏举证的压缩存储
稀疏因子 小于等于0.05的矩阵被称为稀疏矩阵
1. 零值元素占的空间太大
2. 计算中进行了很多和0操作的运算

一、三元组顺序表
求转置矩阵，二维数组，时间复杂度为O(n*m)

三、十字链表
对矩阵结构做出变化    

### 5.4 广义表的类型定义

### 5.5 广义表的表示方法

### 5.6 广义表操作的递归函数

## 第六章 树和二叉树
15节
### 6.1 树的类型定义
#### 基本概念
数据对象D
数据关系R
结点: 数据元素+若干指向子节点的分支
结点的度: 分支的个数
树的度: 树中所有结点的度最大值
叶子结点: 度为0的结点
分支结点: 度大于0的结点
从根到结点的路径: 由从根到该结点所经分支和结点构成
孩子结点、双亲结点、兄弟结点、祖先结点、子孙结点
结点的层次: 假设根结点层次为1，第l层结点层次为l+1
树的深度: 叶子结点所在最大层次
森林: 是m棵互不相交的树的集合
任何一颗非空树是一个二元组 Tree = (root,F) 其中root被称为根结点，F被称为子树森林
基本操作：查找 、 插入 、 删除
#### 查找
Root(T); Value(T,cur_e);
Parent(T, cur_e);
LeftChild(T, cur_e); RightSibling(T,cur_e);
TreeEmpty(T); TreeDepth(T);
TraverseTree(T, Visit());
#### 插入
InitTree(&T);
CreateTree(&T,definition);
Assign(T,cur_e,value);
InsertChild(&T,&p,i,c);
DestroyTree(&T);
#### 删除
ClearTree(&T);
DestroyTree(&T);
DeleteChild(&T,&p,i);

有向树 1有确定根，2树根和子树根之间为有向关系
有序树 子结点是否有序
#### 线性结构树结构比较
线性结构|树结构|比较
-|-|-
第一个数据元素|根结点|无前驱
最后一个数据元素|多个叶子结点|无后继
其他数据元素|树中其他结点|一个前驱一个后继<br>一个前驱多个后继

#### 二叉树
五种几个形态，空，根不空子树空，左子树空，右子树空，根不空子树不空

性质1 在第i层上最多2^(i-1)个结点
性质2 深度为h 结点最多 2^h -1 个结点
性质3 任意二叉树，含有n0个叶子结点，n2个度为2的结点，则比存在关系式: n0 = n2 + 1
满二叉树 
完全二叉树 序号和满二叉树一一对应  
性质 n个结点的完全二叉树 深度为 log2n+1
性质 完全二叉树 2*i 左孩子 2*i+1 右孩子 若2*i 或 2*i+1 > n则孩子不存在

一、顺序存储表示
从0开始 2*i+1左子树 2*i+2 右子树
从1开始 2*i 左子树，2*i+1 右子树
二、链式存储表示

先序后序中序
### 6.2 

### 6.3 

### 6.4 

### 6.5 

### 6.6 

### 6.7 

### 6.8 
